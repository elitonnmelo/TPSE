# 1. Translate the following hexadecimal numbers to binary. 0x0, 0x10, 0xF, 0x1F, 0xA4, 0xFF

## RESPOSTAS
<br>

### 0x0 : 0000 0000
### 0x10: 0001 0000
### 0xF : 0000 1111
### 0X1F: 0001 1111
### 0xA4: 1010 0100
### 0xFF: 1111 1111

# 2. Find the bitwise and, or and xor of the following:

## RESPOSTAS:
<br>

### A: 0xC6 with 0x35
#### 1100 0110 & 0011 0101 -> TRUE 0000 0100
#### 1100 0110 | 0011 0101 -> TRUE 1111 0111
#### 1100 0110 ^ 0011 0101 -> TRUE 1111 0011
### B: 0x19 with 0x24
#### 0001 1001 & 0010 0100 -> FALSE 0000 0000
#### 0001 1001 | 0010 0100 -> TRUE 0011 1101
#### 0001 1001 ^ 0010 0100 -> TRUE 0011 1101
### C: 0xD3 with 0xC7
#### 1101 0011 & 1100 0111 -> TRUE 1100 0011
#### 1101 0011 | 1100 0111 -> TRUE 1101 0111
#### 1101 0011 ^ 1100 0111 -> TRUE 0001 0100
### D: 0x17 with 0xFF
#### 0001 0111 & 1111 1111 -> TRUE 0001 0111
#### 0001 0111 & 1111 1111 -> TRUE 1111 1111
#### 0001 0111 & 1111 1111 -> TRUE 1110 1000
<br>

# 3. Find the 1’s complement of the following: 0xC6, 0x35, 0xD3 and 0xC7.

## RESPOSTAS:
<br>

### 0xC6 -> 1100 0110 -> 0011 1001 -> 0011 1010
### 0x35 -> 0011 0101 -> 1100 1010 -> 1100 1011
### 0xD3 -> 1101 0011 -> 0010 1100 -> 0010 1101
### 0xC7 -> 1100 0111 -> 0011 1000 -> 0011 1001
<br>

# 4. In this question & is bitwise and, | is bitwise or, ^ is bitwise xor, and ! is 1’s complement. a is any given two digit hexadecimal number. Explain why each of the following identities holds.

## RESPOSTAS:
### A:  0xFF & a = a. (0xFF is the identity for AND)
#### VERDAEIRO, POIS PARA QUE A CONDICAO & SEJA VERDADEIRA E NECESSARIO QUE OS BITS SEJAM 1 & 1, JA QUE FF E 1111 1111, LOGO A OPERACAO VAI SER DE ACORDO COM O VALOR QUE FOR COMPARADO.
### B:  0xFF | a = 0xFF. (0xFF is the absorbent for OR)
#### VERDADEIRO, POIS PARA QEU A OPERCAO | SEJA VERDADEIR A E PRECISO APENAS QUE UM DOS BITS SEJAM VERDADEIRO, JA QUE ESTA SENDO COMPARADO UM NUMERO QUALQUER COM O NUMERO 0xFF QUE E 1111 1111, LOGO O RESULTADO ACARRETARA EM 0xFF OU SEJA 1111 1111 
### C: 0xFF ^ a = !a
#### FALSO, O RESULTADO DA CERTO SO QUANDO INVERTE OS NUMEROS, MAS QUANDO E SOMADO +1 O RESULTADO FICA DIFERENTE EX: 1100 1001 ^ 1111 1111 = 0011 0110; JA !1100 1001 = 0011 0111, LOGO SAO DIFERENTES
### D:  0 & a = 0. (0 is the absorbent for AND)
#### VERDADEIRO, POIS NA OPERACAO BIT A BIT NA CONDICAO &, PARAQUE SEJA VERDADEIRO OS AMBOS OS BITS DEVEM SER, E QUANDO COMPARAMOS 0 & UM NUMERO QUALQUER SEMPRE VAI SER 0.
### E: 0 | a = a. (0 is the identity for OR)
#### VERDADEIRO, POIS NA OPERACAO BIT A BIT | PARA QUE SEJA VERDADEIRO, E PRECISO QUE APENAS QUE UM DOS BITS SEJAM 1, LOGO QUANDO SE COMPATA 0 | UM NUMERO QUALQUER, O RESULTADO VAI SER O MESMO NUMERO QUE FOI COMPARADO DEVIDO ESTA COMPARANDO 0  COM O QUE ESTIVE NO BIT.
### F:  0 ^ a = a. (0 is the identity for XOR)
#### VERDADEIRO, POIS A OPERACAO BIT A BIT ^ SO DA VERDADEIRO COM OS BITS SAO DIFERENTE, LOGO  SEMPRE QUIE A OPERACAO ENVOLVER UM 1  O RESULTADO VAI SER 1  E SEMPRE QUE TIVER 0 O RESULTADO VAI SER 0, JA QUE QUANDO COMPARAMOS DOIS BITS IGUAIS O RESULTADO É 0.
### G:   a ^ a = 0 (a is its own inverse under XOR)
#### VERDADEIRO, POIS COMO FOI DITO NO ITEM ACIMA, A OPERACAO ^ RETORNA VERDADEIRO APENAS QUANDO OS BITS SAO DIFERENTES, OU SEJA 1 ^ 0 = 1, OU 0 ^ 1 = 1, JA QUANDO TEMOS BITS IGUAIS  COM 1 ^ 1 OU 0 ^ 0 O RESULTADO VAI SER 0, LOGO POR ESTARMOS COMPARANDO DOIS VALORES IGUAIS O RESULTADO DESSA OPERACAO SERA 0.
### H:  For any three two digit hexadecimal numbers a, b and c: If a ^ b = c then a ^ c = b.
#### VERDADEIRO, POIS A OPERACAO ^ E REVERSIVEL, OU SEJA SE APLICARMOS A OPERACAO ^ DUAS VEZES VOLTAREMOS AO VALOR ORIGINAL


# 5. Write a program that counts the number of bits set in an integer. For example, the number 5 (decimal), which is 0000000000000101 (binary), has two bits set.

## RESPOSTAS EM ARQUIVOS SEPARADO (contadorBinario.c)

# 6. Write a program that takes a 32-bit integer (long int) and splits it into eight 4-bit values. (Be careful of the sign bit.)

## RESPOSTAS EM ARQUIVOS SEPARADO (longBinario.c)

# 7. Write a program that will take the bits in a number and shift them to the left end. For example, 01010110 (binary) would become 11110000 (binary).

## REPOSTAS EM ARQUIVO SEPARADO (delocamentoBin.c)